**算法思路**<br>
1. 定义一个队列Q,并把所有入度为0的结点加入队列
2. 取出队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点入度减为0，则将其加入队列。
3. 反复进行2操作，知道队列为空。如果队列为空时入过队的结点数目恰好为N，说明拓扑排序为空，图G为有向无环图；否则，拓扑排序失败，图G中有环。可使用邻接表实现拓扑排序，显然，由于需要记录结点的入度，因此需要额外建立一个数组inDegree[maxv]，并在程序一开始读入图时就记录好每个结点的入度。接下来就只需要按上面所说的步骤进行实现即可，拓扑排序代码如下：
```
vector<int> G[maxv];//邻接表
int n, m, inDegree[maxv];//顶点数，入度
//拓扑排序
bool topplogicalSort()
{
    int num = 0;//记录加入拓扑序列的顶点数
    queue<int> q;
    for (int i = 0; i < n; i++)
    {
        if (inDegree[i] == 0)
            q.push(i);//将所有入度为0的顶点入队
    }
    while (!q.empty())
    {
        int u = q.front();//取队首顶点u
        //printf("%d",u); //此处可输出顶点u，作为拓扑排序中的顶点
        q.pop();
        for (int i = 0; i < G[u].size(); i++)
        {
            int v = G[u][i];//u的后继结点v
            inDegree[v]--;//顶点v的入度减1
            if (inDegree[v] == 0)
            {
                //顶点v的入度减为0则入队
                q.push(v);
            }
        }
        G[u].clear();//清空顶点u的所有出边(如无必要可不写)
        num++;//加入拓扑序列的顶点数加1
    }
    if (num == n)
        return true;//加入拓扑排序的顶点数为n，说明拓扑排序成功
    else
        return false;//加入拓扑排序的顶点数小于n，说明拓扑排序失败
}

```
如果要求有多个入度为0的顶点，选择编号最小的顶点，那么把queue改成priority_queue，并保持队首元素（堆顶元素）是优先队列中最小的元素即可（当然用set也是可以的）
